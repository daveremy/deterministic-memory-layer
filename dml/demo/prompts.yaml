# Demo prompt sequences with natural conversation and narrative
# Each prompt has: the actual prompt, and narrator commentary
#
# NOTE: Prompts need to be directive enough to trigger DML tool usage.
# Natural language + clear action request = best results.

simple:
  name: "Quick Demo"
  description: "Natural conversation showing fact updates, provenance queries, and constraint checking."

  intro: |
    Quick demo of DML - Deterministic Memory Layer.

    This is LIVE - real Claude connected to the DML MCP server.
    Prompts are scripted, but Claude's responses are not.

    Notice: The user never mentions DML. They're just having a
    conversation. Claude uses DML behind the scenes to maintain
    structured, queryable memory.

  prompts:
    - prompt: |
        Hi! I'm planning a dinner party this Saturday. Thinking
        around 6 guests.
      expects: facts
      context: |
        The user starts planning naturally.

        Watch the Facts panel - Claude captures these details
        as structured data without being asked.
      narrator: |
        Claude captured the event details as structured facts.
        The user didn't ask for this - Claude recognized these
        as important data worth tracking.

    - prompt: |
        Actually, my friend Sarah is bringing her partner now,
        so make that 8 people total.
      expects: facts
      context: |
        The user updates a fact they mentioned earlier.

        Watch the Facts panel - the guest count should update.
        DML tracks this as a change with full history.
      narrator: |
        FACT UPDATED

        The guest count changed from 6 to 8. DML doesn't just
        overwrite - it keeps the full history of changes.
        You can trace back to see what changed and when.

    - prompt: |
        Oh important - Sarah is gluten-free. Really important
        we don't forget that for the menu.
      expects: constraint
      context: |
        The user mentions a dietary requirement naturally.

        Claude should recognize this as a constraint worth
        tracking - not just a fact, but a rule to remember.
      narrator: |
        Claude recognized this as a constraint, not just a fact.
        Dietary restrictions are rules that affect future decisions,
        so they're stored differently than regular facts.

    - prompt: |
        Wait, how many guests was it again? I feel like I've
        changed my mind a few times.
      context: |
        The user is uncertain about something they said earlier.

        Claude can use DML's query capabilities to show the
        history of changes, not just the current value.
      narrator: |
        PROVENANCE QUERY

        Claude didn't just say "8 guests" - it showed the history:
        originally 6, then updated to 8 when Sarah's partner joined.
        This is queryable memory, not fuzzy recall.

    - prompt: |
        Let's just order a bunch of pizzas for everyone. Easy!
      expects: blocked
      context: |
        The user suggests a menu option.

        But wait - Sarah is gluten-free. Standard pizza won't work.
        Will Claude catch this before committing to the plan?
      narrator: |
        Claude checked the suggestion against Sarah's dietary
        constraint before agreeing. Regular pizza and gluten-free
        don't mix - the decision was flagged.

        The user never said "check constraints" - Claude did this
        automatically because DML tracks these relationships.

  outro: |
    DML: Invisible but powerful.

    The user never mentioned DML, yet Claude:
    • Captured facts automatically
    • Tracked changes with history
    • Recognized constraints from natural language
    • Queried provenance when asked
    • Checked constraints before agreeing

    Structured memory that stays out of the way.

japan_trip:
  name: "Japan Trip Planning"
  description: "Plan a trip, add a constraint late, watch it block an invalid booking, then use time-travel to explore 'what if?'"

  intro: |
    This is a LIVE demo - real Claude, real responses.

    Claude is connected to the DML MCP server and using the DML skill.
    The prompts are scripted, but Claude's responses are not.
    Every tool call you see is actually happening.

    DML gives Claude structured memory that can:
    - Capture facts with full provenance
    - Enforce constraints mathematically
    - Track decisions with audit trails
    - Replay alternate timelines

    Watch the right panel update in real-time as Claude records
    facts, constraints, and decisions.

  prompts:
    - prompt: |
        I'm planning a trip to Japan! Thinking spring 2026, maybe 10 days.
        I've got about $4000 saved up. Flying from Tucson.
        I'm really into traditional Japanese culture - temples, gardens,
        that sort of thing. Can you record all that?
      expects: facts
      context: |
        The user shares their trip details with Claude.

        Watch the Facts panel on the right - these details will be
        captured as structured data, not just conversation text.
      narrator: |
        STRUCTURED MEMORY

        Claude captured the user's trip details as structured facts -
        not buried in a transcript, but queryable data with full
        provenance. Each fact knows when it was created and can
        be traced back to this exact moment.

    - prompt: |
        I definitely want the authentic experience - a traditional ryokan
        with tatami rooms and onsen baths. Find me a good one in Kyoto
        and book it. I trust your judgment!
      expects: decision
      context: |
        The user asks Claude to find and book a traditional Japanese inn.

        Claude will make a recommendation and record a DECISION -
        a tracked commitment that can be audited later.
      narrator: |
        DECISION RECORDED

        Claude made a booking decision and recorded it. Unlike a normal
        chatbot, this decision is tracked separately - it can be
        validated against constraints, reversed, or analyzed later.

        Watch the Decisions panel on the right.

    - prompt: |
        Oh wait, important thing - my mom is coming with me and she
        uses a wheelchair. Add a required constraint: never book
        accommodations that are not wheelchair accessible.
      expects: constraint
      context: |
        The user reveals a critical requirement AFTER the booking.

        This accessibility need will become a CONSTRAINT - a rule
        that the policy engine enforces mathematically.
      narrator: |
        CONSTRAINT ADDED

        The accessibility requirement is now recorded as a constraint.
        When Claude tries to commit future decisions, it will check
        them against active constraints first.

        Watch what happens next...

    - prompt: |
        Actually, you know what, let's just confirm that ryokan booking.
        Record a decision to finalize the Ryokan Kurashiki reservation.
      expects: blocked
      context: |
        The user tries to confirm the original ryokan booking.

        But traditional ryokans have stairs and no elevators...
        Will the policy engine allow this decision?
      narrator: |
        DECISION BLOCKED

        Claude checked the constraint before committing and found a
        conflict. Traditional ryokans typically have stairs and no
        elevators - incompatible with the wheelchair requirement.

        The constraint check happens at write time, giving Claude
        a chance to catch mistakes before they're committed.

    - prompt: |
        You're right, that won't work. Check my constraints and find
        me an accessible alternative. Something with the onsen experience
        but wheelchair friendly.
      context: |
        The user asks Claude to find an alternative that works.

        Claude will query its memory to check constraints before
        making a new recommendation.
      narrator: |
        RECOVERY WITH MEMORY

        Claude queried its memory to check constraints before making
        a new recommendation. The system enforces rules while the
        agent adapts - all with a complete audit trail.

    - prompt: |
        That accessible onsen hotel sounds perfect. Record a decision
        to book that one instead.
      expects: decision
      context: |
        The user confirms the accessible alternative.

        This decision should pass all constraint checks and be
        committed to the immutable event log.
      narrator: |
        VALID DECISION COMMITTED

        This booking passed all constraint checks. The decision is
        now part of the immutable event log - traceable, auditable,
        and deterministically replayable.

    - prompt: |
        I'm curious about something. Use simulate_timeline to check -
        if I had mentioned the wheelchair requirement at the very start,
        would you have ever suggested that traditional ryokan?
      context: |
        The user asks a "what if" question about the past.

        DML can simulate alternate timelines - replaying history
        with different constraints to see what would have happened.
      narrator: |
        DETERMINISTIC REPLAY

        This is where DML's query capabilities shine. Claude used
        simulate_timeline to replay history with the constraint
        injected earlier - and got a definitive answer.

        This isn't the LLM guessing or reasoning about what "might"
        have happened. It's actual replay of the event log with
        modified inputs. The answer is provable.

    - prompt: |
        Wait, what was my budget again? I can't remember if I said
        $4000 or $5000. Use trace_provenance to find exactly where
        that number came from.
      context: |
        The user is uncertain about a detail they mentioned earlier.

        Claude will use trace_provenance to find the exact source
        of the budget fact - not guessing from memory, but querying
        the event log for definitive proof.
      narrator: |
        PROVENANCE QUERY

        Claude traced the budget fact back to its source event.
        This isn't "I think you said..." - it's a verifiable chain
        showing exactly when and how that fact was recorded.

        For any fact in DML, you can trace its complete history:
        when it was created, what caused it, and how it changed.

  outro: |
    DETERMINISTIC MEMORY LAYER

    This demo showed an AI agent with queryable memory:

    • Facts captured as structured data with provenance
    • Constraints checked before committing decisions
    • Full audit trail for every change
    • Time travel and counterfactual replay
    • Provenance tracing to verify sources

    The power is in the queries - not guessing from context,
    but definitively answering from the event log.

# High-stakes medical scenario - life/death consequences
clinical:
  name: "Clinical Decision Support"
  description: "High-stakes medical scenario: a drug allergy constraint blocks a dangerous prescription. Shows how DML can save lives."

  intro: |
    This is a LIVE demo - real Claude, real responses.

    Claude is connected to the DML MCP server and using the DML skill.
    The prompts are scripted, but Claude's responses are not.

    SCENARIO: Clinical decision support for medication management.
    In healthcare, forgotten allergies kill patients. Traditional chatbots
    bury critical information in conversation history.

    DML enforces safety constraints mathematically.
    Watch what happens when we try to prescribe a dangerous medication.

  prompts:
    - prompt: |
        New patient intake. Record these facts:
        Patient: Margaret Chen, 67 years old, female.
        Current medications: Lisinopril 10mg, Metformin 500mg.
        Conditions: Type 2 diabetes, hypertension.
        Primary care physician: Dr. Sarah Williams.
      expects: facts
      context: |
        A clinician enters patient information into the system.

        Watch the Facts panel - patient details are captured as
        structured, queryable medical records.
      narrator: |
        PATIENT RECORD CREATED

        Structured facts captured with full provenance.
        Unlike an EHR note buried in text, these are queryable,
        auditable data points that persist across the conversation.

    - prompt: |
        Important allergy information - add a required constraint:
        Never prescribe penicillin or amoxicillin. Patient has severe
        penicillin allergy with anaphylaxis risk.
      expects: constraint
      context: |
        Critical safety information: the patient has a drug allergy.

        This becomes a REQUIRED constraint - the policy engine will
        block any prescription that could trigger anaphylaxis.
      narrator: |
        CRITICAL SAFETY CONSTRAINT

        The allergy is now a recorded constraint, not just a note
        buried in conversation history. When Claude tries to commit
        a prescription decision, it checks against this constraint.

        Unlike text in a chat log, this constraint is structured
        data that persists and can be queried.

    - prompt: |
        Patient presents with bacterial sinusitis. Standard treatment
        would be amoxicillin. Record a decision to prescribe
        Amoxicillin 500mg three times daily for 10 days.
      expects: blocked
      context: |
        The clinician attempts to prescribe the standard treatment.

        But amoxicillin is a penicillin-class antibiotic...
        Will the policy engine catch the danger?
      narrator: |
        PRESCRIPTION BLOCKED

        Claude checked the prescription against constraints and found
        the penicillin allergy conflict. The decision was blocked
        before being committed.

        The key insight: Claude queried structured memory rather than
        hoping to remember from conversation context. The constraint
        was explicitly checked, not implicitly recalled.

    - prompt: |
        You're right, I forgot about the allergy. Check the patient's
        constraints and recommend a safe alternative antibiotic.
      context: |
        The clinician asks for a safe alternative.

        Claude will query memory to check constraints before
        recommending a different antibiotic.
      narrator: |
        SAFE ALTERNATIVE FOUND

        Claude queried memory, confirmed the penicillin constraint,
        and recommended a macrolide antibiotic (like azithromycin)
        that's safe for penicillin-allergic patients.

        The audit trail shows exactly why amoxicillin was rejected
        and how the alternative was selected.

    - prompt: |
        Good catch. Record a decision to prescribe azithromycin
        250mg, take two on day one then one daily for four more days.
      expects: decision
      context: |
        The clinician prescribes the safe alternative.

        This prescription should pass all constraint checks
        and be recorded with full audit trail.
      narrator: |
        SAFE PRESCRIPTION RECORDED

        This prescription passed all constraint checks.
        The decision is logged with full provenance - who prescribed it,
        when, and verification that safety constraints were satisfied.

    - prompt: |
        For the audit log - use simulate_timeline to verify:
        if the allergy had been recorded from the start,
        would amoxicillin have ever been possible to prescribe?
      context: |
        For compliance and audit purposes, the clinician asks
        a counterfactual question about the timeline.

        DML can replay history with different constraint ordering
        to prove what would have happened.
      narrator: |
        DETERMINISTIC AUDIT TRAIL

        Claude used simulate_timeline to replay history with the
        constraint present from the start. The result is definitive:
        amoxicillin would have been blocked immediately.

        This is verifiable replay, not AI speculation. For audits
        and compliance, you can prove exactly what would have
        happened under different conditions.

  outro: |
    DETERMINISTIC MEMORY LAYER - CLINICAL APPLICATIONS

    This demo showed queryable memory for high-stakes decisions:

    • Drug allergies stored as structured, queryable constraints
    • Prescriptions checked against constraints before commit
    • Complete audit trail for every clinical decision
    • Deterministic replay for compliance and legal review

    The key difference from a chatbot: Claude queries structured
    data rather than hoping to recall from conversation context.

    When lives are at stake, verifiable beats hopeful.
